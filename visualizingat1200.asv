%%
clear all; close all; clc;
load surfaceData1200.mat 
load surfMesh.mat
%% Plots only the surface at s = 1200
x = xMesh; y = yMesh; z = surfaceData1200;

% Read data reads data as (y, x, z)

h = surf(x, y, z);

set(h, 'EdgeColor','none')   % hide black grid lines
shading interp;      % optional – smooths the surface
colormap parula;        % optional – sets color map
colorbar;            % optional – adds color bar
zlim([-2 2]); %Adjust z reasonably
xlabel('Y');
ylabel('X');
zlabel('Z');
title('Surface Plot of surfaceData1200');


%% Plotting normals
[Nx, Ny, Nz] = surfnorm(x, y, z);
h_norm = surfnorm(y, x, z);

surfnorm(y, x, z);


%% Interpolating and Compare surface normals


% Make Ngrid based on mesh
[xa, ix] = sort(x(1,:));       % X axis (cols)
[ya, iy] = sort(y(:,1));       % Y axis (rows)

% Evaluate Z on Ngrid
Za = z(iy, ix);                % reorder Z to match sorted axes

% Make a meshgrid based on Ngrid
[Xo, Yo] = meshgrid(xa, ya);   % original node grid

% --- 2) Interpolant built on the same axes ---
F = griddedInterpolant({xa, ya}, Za.', 'linear', 'none');  % F(x,y)

% Evaluate Interpolated surface
Zi = F(Xo, Yo);  % should equal Zo (check)

% Orginal surform
[Nx0, Ny0, Nz0] = surfnorm(Xo, Yo, Za);   % "original" normals

%Interpolated surfnorm
[NxI, NyI, NzI] = surfnorm(Xo, Yo, Zi);   % "interpolated" normals

% Align possible global sign flip
dotp = Nx0.*NxI + Ny0.*NyI + Nz0.*NzI;
if median(dotp,'all') < 0
    NxI = -NxI; NyI = -NyI; NzI = -NzI;
end

% Differences (should be ~machine eps)
maxerr = [max(abs(NxI(:)-Nx0(:))), ...
          max(abs(NyI(:)-Ny0(:))), ...
          max(abs(NzI(:)-Nz0(:)))]

% 5) (Optional) quick check plot
figure; surf(Xo, Yo, Zi);
shading interp; colormap parula; colorbar;
title('Interpolated surface');
zlim([-2 2]); %Adjust z reasonably
xlabel('Y');
ylabel('X');
zlabel('Z');


%% Error
% Assume you've already sorted to xa, ya and reordered Za
[xa, ix] = sort(x(1,:));                % Sort the first row of x and get sorted indices
[ya, iy] = sort(y(:,1));                % Sort the first column of y and get sorted indices
Za = z(iy, ix);                          % Reorder Z based on sorted indices, resulting in Ny×Nx
F  = griddedInterpolant({xa, ya}, Za.', 'linear', 'none');  % Create a gridded interpolant for linear interpolation
[Xn, Yn] = ndgrid(xa, ya);               % Create a grid of points for interpolation (Nx×Ny)
Zhat = F(Xn, Yn);                        % Evaluate the interpolant at the grid points (Nx×Ny)
E = Zhat - Za.';                         % Calculate the error between interpolated and actual values
rmse = sqrt(mean(E(:).^2));              % Compute the root mean square error
mae  = mean(abs(E(:)));                  % Compute the mean absolute error
maxe = max(abs(E(:)));                   % Compute the maximum absolute error
fprintf('RMSE=%.3e, MAE=%.3e, Max=%.3e\n', rmse, mae, maxe);  % Display the error metrics



